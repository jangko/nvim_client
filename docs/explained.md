# Neovim Client Explained
---

## General Overview

The Neovim text editor offers an RPC API to let the editor communicate with external processes.
An API client library provides the functionality to connect to a Neovim process and exchange information with it.
It can be used control Neovim, write remote plugins, or implement a GUI in it.

To illustrate the relationship between Neovim and it's plugins:
```text
   Neovim instance <---- msgpack-rpc ----> Plugin-Host A
           |                         |            |- Plugin K
           |---> Plugin U            |            |- Plugin L
           |---> Plugin V            |            |- Plugin M
           |---> Plugin W            |
                                     |---> Plugin-Host B
                                     |            |- Plugin X
                                     |            |- Plugin Y
                                     |            |- Plugin Z
                                     |
                                     |---> Plugin D
                                     |---> Plugin E
                                     |---> Plugin F
```

Plugin U,V,W are plugins written in vimscript.

Plugin-Host A,B,C are Neovim-Client implementing msgpack-rpc API functionality and responsible
for providing runtime environment for any plugin run inside it.
Usually a Plugin-Host is a Neovim-Client for interpreted language such as Python, Lua, Javascript, Ruby, etc.
The Plugin-Host will provide msgpack-rpc API and load any plugin written in that language.
The language interpreter itself usually will be loaded by small vimscript code/plugin, then the vimscript will load the
Plugin-Host.

Plugin D,E,F are plugins written in compiled language. They don't have host,
they communicate with Neovim with the aid of Neovim-Client library written in that language and
linked against the plugin itself. The plugin will be loaded by small vimscript code/plugin.

Beside the above scenario relationship, a plugin written in any language can also embed Neovim or connect to Neovim.
For example you write a Neovim GUI in your beloved language, when you start the GUI application,
it can start Neovim or connect to a Neovim process and start communicating the same way with regular plugin.
But instead the plugin loaded by vimscript, the plugin itself load the Neovim or connect to an already existed Neovim process.

The above diagram are typical setup. Actually, Neovim instance can be more than one, and they can communicate each other too.

## MessagePack RPC

Neovim-Client libraries normally provide wrappers that hide
[msgpack-rpc](https://github.com/msgpack/msgpack/blob/master/spec.md)
details from application developers. The wrappers can be
automatically generated by reading bundled API metadata from a compiled Nvim
instance.

There are three ways to obtain API metadata:

  * Connect to a running Nvim instance and call `nvim_get_api_info` via
     msgpack-rpc. This is best for clients written in dynamic languages which
     can define functions at runtime.

  * Start Nvim with the |--api-info| option. Useful for clients written in
     statically-compiled languages.

  * Use the |api_info()| vimscript function.

When communicating with Neovim, the client must send or process information encoded in msgpack.
The client send one request packet to Neovim, Neovim will answer with one response packet.
The Neovim send one request packet to client, client will answer with one response packet too.
The Neovim send notification in one packet, the client will respond or ignore it.
There are three types of packet used during communication:

```Nim
  PacketType = enum
    Request = 0
    Response = 1
    Notification = 2
```

### Request Packet

Request packet is an array of four elements:
  * PacketType in integer(Request = 0)
  * unique packet_id in integer(0 to maxInt)
  * method name in string(e.g. "nvim_list_runtime_paths", see API metadata)
  * params is an array of zero or more elements(see API metadata)

### Response Packet

Response packet is an array of four elements:
  * PacketType in integer(Response = 1)
  * unique packet_id in integer(same as packet_id from Request Packet)
  * error is a null if no error or an array of two elements: [errCode in integer, errStr in string]
  * response payload can be anything(see API metadata)

### Notification Packet

Notification packet is an array of three elements:
  * PacketType in integer(Notification = 2)
  * method name in string(see API metadata)
  * params is an array of zero or more elements(see API metadata)

## Transport layer or Channels

Channels are nvim's way of communicating with external processes.

There are several ways to open a channel:

  * Through stdin/stdout when `nvim` is started with `--headless`, and a startup
     script or --cmd  command opens the stdio channel using |stdioopen()|.

  * Through stdin, stdout and stderr of a process spawned by |jobstart()|.

  * Through the PTY master end of a PTY opened with
     `jobstart(..., {'pty': v:true})` or |termopen()|.

  * By connecting to a TCP/IP socket or named pipe with |sockconnect()|.

  * By another process connecting to a socket listened to by nvim. This only
     supports RPC channels, see |rpc-connecting|.
     
The current address in Neovim can be obtained with `:echo v:servername` or `:echo $NVIM_LISTEN_ADDRESS`

Windows
named pipe: open with CreateFile, read with ReadFile, write with WriteFile
socket
stdio

Unix/Posix
unix domain socket: open with socket and connect, read with read, write with write
socket
stdio

Neovim side
stdioopen
jobstart
sockconnect
serverstart

iex -S mix nvim.attach "127.0.0.1:7777"
iex -S mix nvim.attach "[::1]:7777"
iex -S mix nvim.attach "/path/to/unix/domain/sock"

other languages:
  - use whatever provided by your language

how to test your plugin/client during development
NVIM_LISTEN_ADDRESS
$ NVIM_LISTEN_ADDRESS=/tmp/nvim nvim
* (ql:quickload :cl-neovim)
* (nvim:connect :file "/tmp/nvim") 
* (nvim:command "echo 'Hello from Common Lisp!'")



## Plugin Host and Plugin registration

~\AppData\Local\nvim\autoload\

~/.local/share/nvim/site/autoload/

plugin registration plugin
if exists('g:loaded_hello')
  finish
endif
let g:loaded_hello = 1

function! s:Requirehello(host) abort
  " 'hello' is the binary created by compiling the program above.
  return jobstart(['hello'], {'rpc': v:true})
endfunction

call remote#host#Register('hello', 'x', function('s:Requirehello'))
" The following lines are generated by running the program
" command line flag --manifest hello
call remote#host#RegisterPlugin('hello', '0', [
    \ {'type': 'function', 'name': 'Hello', 'sync': 1, 'opts': {}},
    \ ])
    
A remote plugin can define functions, commands and auto-commands for Neovim. Each of these is represented by a Racket callback function which gets called with the necessary arguments applied.

Each of the following procdures takes in a name, a function and a number of keyword arguments. The name is the name under which the function or command will be registered in Neovim and the same restrictions apply as for all user-defined functions and commands in Neovim.

All procedures have a #:sync keyword argument; if it is true the remote call will be synchronous, otherwise it will be asynchronous.

            I am not yet sure about the arity of callback procedures, so take that information with a grain of salt.

        procedure
        (nvim-function	 	name	 	 	 	 
         	 	proc	 	 	 	 
         	 [	#:range range?	 	 	 	 
         	 	#:eval eval	 	 	 	 
         	 	#:sync sync?])	 	→	 	any

      name : string?
      proc : procedure?
      range? : boolean? = #f
      eval : (or/c void? string?) = (void)
      sync? : boolean? = #t

Defines a Neovim function call by the name name, which has to be a valid Neovim function name. If range? is true then proc has arity two, otherwise it has arity one.

proc is a procedure of one or two arguments; the first argument is a vector of arguments passed to the Neovim function, the second argument (if applicable) is a vector of two integers: the first in is the first line of the range, the second one is the last line of the range. The result of proc will be returned by the RPC call.

If sync is false the function call will not block Neovim, but Neovim will not receive the return value of proc, it will use some default value like 0 instead. Asynchronous functions are only useful for their side effects.

        procedure
        (nvim-command	 	name	 	 	 	 
         	 	proc	 	 	 	 
         	 [	#:nargs nargs	 	 	 	 
         	 	#:complete complete	 	 	 	 
         	 	#:range range	 	 	 	 
         	 	#:count count	 	 	 	 
         	 	#:bang bang?	 	 	 	 
         	 	#:register register?	 	 	 	 
         	 	#:eval eval	 	 	 	 
         	 	#:sync sync?])	 	→	 	any

      name : string?
      proc : procedure?
      nargs : (or/c 0 1 #\* #\? #\+) = 0
      complete : (or/c #f string?) = #f
      range : (or/c #f #t #\% exact-nonnegative-integer?) = #f
      count : (or/c #f exact-nonnegative-integer?) = #f
      bang? : boolean? = #f
      register? : boolean? = #f
      eval : (or/c void? string?) = (void)
      sync? : boolean? = #t

Defines a Neovim command by the name name, which has to be a valid Neovim command name. The default arity of proc is zero, but if some keyword arguments are different from their default value the arity is increased by one for each. The order of arguments is the same as the following order of their descriptions.

nargs is either 0 (no arguments), 1 (exactly one argument), #\* (any number of arguments), #\? (zero or one arguments), or #\+ (at least one arguments). The arguments will be passed as a vector to proc (unless nargs is 0, in which case nothing will be passed).

complete is a string describing the completetion method (see :h :command-completetion). This argument does not affect the arity of proc.

range and count are mutually exclusive, and both increase the arity of proc by one. The range is either #f (no range) allowed, #t (range allowed), #\%, or an exact-nonnegative-integer?. The count is either #f (no count) or a exact-nonnegative-integer?. See :h :command-range for details. If count is given or range is an integer, one number representing that count is passed as an argument. For other values (#t and #\%) of range a vector of two numbers is passed, the first one being the first line, the second one the last line.

bang is either #f (no bang allowed) or #t (bang allowed). If #t, an integer will be passed to proc indicating whether the bang was specified (non-zero) or not (zero).

register is either #f (no register allowed) or #t (register allowed). If #t, a string containing the register name will be passed to proc. If no register was given that string will be empty.

        procedure
        (nvim-autocmd	 	name	 	 	 	 
         	 	proc	 	 	 	 
         	 [	#:pattern pattern	 	 	 	 
         	 	#:eval eval	 	 	 	 
         	 	#:sync sync?])	 	→	 	any

      name : string?
      proc : procedure?
      pattern : string? = "*"
      eval : (or/c void? string?) = (void)
      sync? : boolean? = #f

Defines a Neovim auto-command by the name name, which has to be a valid Neovim auto-command name. The arity of proc is zero.

The pattern is a string describing the pattern of the auto-command, see :h autocmd-patterns for details.